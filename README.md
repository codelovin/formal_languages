## Практикум №1 по формальным языкам

##### Работа выполнена студентом Шахраем Владиславом, группа 595

###Постановка задачи.
На вход программе подается регулярное выражение, задающее язык L, состоящее из
* букв фиксированного алфавита a, b, c
* символа пустого слова 1
* знака конкатенации .
* знака альтернации +
* знака, отвечающего за звезду Клини *
Также на вход подается символ x, не обязательно лежащий в алфавите.
Задача: вычислить наибольшее значение k такое, что x^k является подсловом некоторого w, лежащего в L.

###Обработка регулярного выражения
Перед решением задачи, регулярное выражение проверяется на валидность. Это легко реализуется при помощи подсчета баланса операций (по типу стека) в публичной статической функции

	    static bool checkRegex(std::string s);

###Построение автомата
Автомат строится абсолютно формально. Стандартный конструктор отвечает за автомат с единственным начальным и финальным состоянием. Также заранее реализуется автомат, отвечающий за язык, задаваемый одним символом. Операции конкатенации ., альтернации + и звезды клини (унарная операция) по двум (одному) автоматам реализованы интуитивно просто в методах:

    	static FSA concatenate (FSA first, FSA second);
 	    static FSA alternate (FSA first, FSA second);
    	static FSA kleene (FSA other);

<b>Bugfix#2:</b> В первых двух версиях решения, метод alternate был реализован неверно. Именно, исходная вершина всегда считалась завершающей.

###Алгоритм

В первых двух версиях решения, мы убирали все эпсилон-переходы из автомата. Это оказалось ненужным. Теперь мы не убираем эпсилон-переходы из автомата.

Далее - запускаем DFS из каждой вершины и помечаем ее цвет в черный. По ребрам мы ходим только в том случае, если ребро имеет символ x или эпсилон. Параллельно будем хранить баланс встретившихся нам иксов в параметре currentK, передавая его в DFS. Таким образом, для всех когда-либо достижимых состояний q, мы найдем все слова, состоящие из x, стартующих из состояния q.

<b>Важно:</b>
Как понять, что мы нашли непустой цикл и максимального k не существует?
* мы прошли по ребру x в вершину, помеченную черным
* мы прошли по ребру эпсилон в вершину, помеченную черным, и баланс иксов в текущей цепочке DFS-a не менее 1. Это означает, что мы из исходной вершины можем еще раз пройти по цепочке, и так далее.
Ответ в данной ситуации будет равен INF.

Проходя таким образом, мы записываем ответ в приватную переменную answer,которую затем восстанавливаем с помощью метода getAnswer() и выводим на экран.

###Анализ
Данный алгоритм совсем не обязательно работает на НКА, построенных иным образом. Легко приводится пример с регулярным выражением (ab+ba)*, в котором при интуитивном построении минимального НКА алгоритм работать не будет.
Асимптотика предложенного решения составляет О(N^2) + О(M) = O(N^2), где M - длина рег. выражения, а N - размер автомата.


